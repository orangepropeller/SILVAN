<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 278f379f-4ca9-476e-bf94-b1a55f9bb1d1 (2025-11-24 12:52Z) -->

# Understanding source code file functionalities (2025-11-24 12:52Z)

_**User (2025-11-24 07:21Z)**_

Please explain the functionality of each source code file in @silvan so I fully understand the algorithm implementation

---

_**Agent (model gemini-3-pro, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Listing Silvan Files**

I'm currently listing the files within the `silvan/` directory and its subdirectories, specifically `src/` and `include/`. The goal is to prepare for a thorough analysis of each source code file. It's a fundamental step, but necessary to set up further progress.


**Analyzing Silvan's Purpose**

Now I'm delving deeper, mapping out the architecture. The immediate next step involves parsing the contents of the listed source files, aiming to distill their roles within the broader `silvan/` project. I'm focusing on function signatures, class definitions, and key comments to build my understanding.


</details></think>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Grouping the Files**

I've organized the files. Now, I'm pairing `Graph.cpp` and `Graph.h` because, naturally, those belong together. Next, I'll move on to analyzing `main.cpp` as the entry point, starting with the includes.


**Organizing My Approach**

I'm solidifying my approach: Grouping by functionality is key. I'll pair `.cpp` and `.h` files. `main.cpp` is up next for initial flow understanding. I'll prioritize headers to grasp the classes and functions, supplementing with source code when needed for clarity.


</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/main.cpp</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/include/Graph.h</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/include/Probabilistic.h</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/include/Rand_gen.h</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/include/Ranking_list.h</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/include/Sp_sampler.h</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/include/utilities.h</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Detailing the Implementation**

I'm now diving into the source files to flesh out my understanding. Specifically, I'm poring over `silvan/src/Graph.cpp`, `silvan/src/Probabilistic.cpp`, and `silvan/src/Sp_sampler.cpp` to grasp the implementation nuances. This deep dive should cement the practical aspects.


**Outlining the Strategy**

I've crafted a plan. To keep things manageable, I'm splitting the source file review into two phases. The initial batch includes `Graph.cpp`, `Rand_gen.cpp`, `Ranking_list.cpp`, and `utilities.cpp`. Following that, I'll tackle the more intricate `Sp_sampler.cpp` and `Probabilistic.cpp` files. This strategic division should ease the process.


</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/src/Graph.cpp</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/src/Rand_gen.cpp</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/src/Ranking_list.cpp</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/src/utilities.cpp</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Assessing the Codebase**

I've been going through the code. So far, I've got a handle on Graph.cpp; it seems to be managing the core graph functionalities, with some standard algorithms like potentially Tarjan's for connectivity. I also checked out Rand_gen.cpp, which appears straightforward with its linear congruential generator. Currently, I'm taking a look at Ranking_list.


**Reviewing Key Algorithms**

My focus has shifted to the core algorithms. I've finished a quick review of the basic files. Now, I'm wading into the algorithmic heart of the matter, specifically `Sp_sampler.cpp` and the notably large `Probabilistic.cpp`. The sheer size of the latter is a bit daunting, so I will take it in bite-sized chunks to digest the logic.


</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/src/Sp_sampler.cpp</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/src/Probabilistic.cpp</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Understanding the Files**

I've finally finished reading through all the files. My next step is to summarize the function of each and clarify the algorithm used. Initial summaries of main.cpp, graph.h, and graph.cpp are complete. Now I'm moving on to algorithm implementations.


**Clarifying Algorithm Steps**

I'm presently dissecting the `Rand_gen` functions. My understanding is solid on `main.cpp` and the graph data structure. I've begun mapping out how the random number generator interacts with the graph algorithms. The next phase will be to outline how the algorithm leverages these components.


**Outlining the Core Algorithm**

Now that the file summaries are complete, I'm focusing on the algorithm's mechanics. The `Sp_sampler` functions are next. My understanding of the random path selection and BFS implementation is growing. I am now trying to deduce how the shortest paths are used to find the betweenness centrality approximations, and how that interacts with the `Ranking_list` class. The stopping criteria are next.


**File Functionality Review**

I've finished synthesizing the functionality of each file and am ready to clarify the core algorithm. `main.cpp` handles setup, while the `Graph` class manages the data structure. The random number generator is a simple LCG. `Ranking_list` tracks the top-k nodes, and `Sp_sampler` performs the core shortest path sampling, utilizing bidirectional BFS and path backtracking. `Probabilistic` implements the overall approximation, running multiple rounds to refine the estimates.


**Understanding File Summaries**

I've finished synthesizing the functionality of each file. `main.cpp` handles argument parsing and algorithm execution. The `Graph` class manages graph loading and manipulation, including SCC computation and diameter estimation. The `Rand_gen` provides a simple LCG. `Ranking_list` maintains the top-k nodes. `Sp_sampler` implements bidirectional BFS and shortest path sampling. `Probabilistic` orchestrates the core approximation algorithm, calling `Sp_sampler` repeatedly. Lastly, the `utilities` file provides basic timing functions.


**Reviewing File Descriptions**

I'm now consolidating the file descriptions. `main.cpp` handles command-line argument parsing and algorithm initiation. The `Graph` class manages the graph data structure and core operations. The `Rand_gen` provides the random number generation. The `Ranking_list` class maintains the top-k nodes, while `Sp_sampler` implements shortest path sampling using bidirectional BFS. The `Probabilistic` class executes the main approximation algorithm, and `utilities` provides timing functions.


**Summarizing the Functionality**

I'm now consolidating the file descriptions. I understand `main.cpp` handles setup, parsing, and execution. The `Graph` class manages graph data and operations, including diameter estimation and SCC calculation. The `Rand_gen` provides the random number generation, while `Ranking_list` tracks the top-k nodes. I've now refined my comprehension of `Sp_sampler` which uses bidirectional BFS. Finally, the `Probabilistic` class executes the main algorithm using an adaptive stopping condition, with `utilities` providing timing functions.


**Understanding File Summaries**

I'm now consolidating the file descriptions. `main.cpp` handles command-line arguments and algorithm execution. The `Graph` class loads and manages the graph data. `Rand_gen` provides the random numbers, and `Ranking_list` maintains the top-k nodes. `Sp_sampler` performs shortest path sampling using bidirectional BFS. `Probabilistic` implements the core algorithm using an adaptive stopping condition, with `utilities` providing timing.


</details></think>

---

[I WILL OBEY THE USER RULES]

Here is the explanation of the functionality for each source code file in the `silvan` directory.

### Overview
The **Silvan** project implements a high-performance, parallel algorithm for approximating **Betweenness Centrality (BC)** in large graphs. It uses a Monte Carlo sampling approach with an adaptive stopping condition based on Rademacher Averages (referenced as "MCRADE" in the code). The algorithm samples random shortest paths, updates centrality estimates, and stops when the statistical error guarantees ($\epsilon, \delta$) are met.

### Source Code File Analysis

#### 1. `silvan/main.cpp`
*   **Functionality**: The entry point of the application.
*   **Key Responsibilities**:
    *   **Argument Parsing**: Handles command-line flags (e.g., `-k` for top-k, `-d` for directed graphs, `-o` for output file) and validates inputs like $\epsilon$ (error) and $\delta$ (confidence).
    *   **Initialization**: Sets up the OpenMP environment (threading) and instantiates the `Probabilistic` class.
    *   **Execution**: Calls `Probabilistic::run()` to start the approximation algorithm and prints the final status.

#### 2. `silvan/src/Graph.cpp` (and `include/Graph.h`)
*   **Functionality**: Manages the graph data structure and basic topological operations.
*   **Key Responsibilities**:
    *   **Data Structure**: Stores the graph using **Adjacency Lists** (`adj`) and, if directed, **Incidence Lists** (`inc`) for backward traversal.
    *   **Loading**: Reads the graph from an edge-list text file.
    *   **Preprocessing**:
        *   **SCC**: Computes Strongly Connected Components using a DFS-based approach (Tarjan's-like) to handle connectivity.
        *   **Diameter Estimation**: The `estimate_diameter` function calculates an upper bound on the graph's diameter. This is critical because the sample size required for convergence depends on the graph diameter.

#### 3. `silvan/src/Sp_sampler.cpp` (and `include/Sp_sampler.h`)
*   **Functionality**: The core sampling engine that efficiently generates random shortest paths.
*   **Key Responsibilities**:
    *   **Bidirectional BFS**: For a random pair of nodes $(u, v)$, it performs a balanced bidirectional BFS to find all shortest paths between them. It expands from the side with fewer edges to optimize performance.
    *   **Path Counting**: During the BFS, it counts the number of shortest paths passing through each node (`n_paths`) to ensure uniform sampling.
    *   **Backtracking**: The `random_path` and `backtrack_path` functions use the path counts to reconstruct *one* specific shortest path randomly from the set of all shortest paths between $u$ and $v$.
    *   **Sampling**: Returns the nodes found on this path to the caller.

#### 4. `silvan/src/Probabilistic.cpp` (and `include/Probabilistic.h`)
*   **Functionality**: Implements the high-level approximation algorithm and statistical stopping conditions.
*   **Key Responsibilities**:
    *   **Algorithm Flow (`run`)**:
        1.  **First Pass**: Runs a small initial batch of samples to estimate parameters (like empirical peeling/variance).
        2.  **Second Pass**: Continuously calls `Sp_sampler` to sample paths in parallel.
    *   **Estimation**: Updates the `approx` array (BC estimates) for every node found on sampled paths.
    *   **Stopping Condition (MCRADE)**:
        *   Instead of using fixed sample sizes, it periodically checks if the approximation is accurate enough.
        *   It uses **Rademacher Averages** (computed via the `mcrade` array and random `sigmas`) and **Empirical Bernstein Bounds** (`emp_wimpy_vars`) to measure the convergence rate.
        *   **`compute_finished_mcrade`**: Checks if the supremum deviation is within the error bound $\epsilon$.
        *   **`check_topk_guarantees`**: For top-k queries, it ensures the top-k nodes are distinct enough from the rest to guarantee the ranking is correct within the error bounds.

#### 5. `silvan/src/Ranking_list.cpp` (and `include/Ranking_list.h`)
*   **Functionality**: A specialized data structure to track the "Top-K" nodes.
*   **Key Responsibilities**:
    *   Maintains a list of the $k$ nodes with the highest centrality estimates found so far.
    *   Provides a `put` method to update a node's value and resort the list, ensuring efficient access to the current top-k candidates during the frequent checks in `Probabilistic.cpp`.

#### 6. `silvan/src/Rand_gen.cpp` (and `include/Rand_gen.h`)
*   **Functionality**: A lightweight pseudo-random number generator.
*   **Key Responsibilities**:
    *   Implements a **Linear Congruential Generator (LCG)** using constants from Knuth's MMIX.
    *   Used by `Sp_sampler` to pick random node pairs and by `Probabilistic` for the Rademacher random signs.

#### 7. `silvan/src/utilities.cpp` (and `include/utilities.h`)
*   **Functionality**: Helper functions.
*   **Key Responsibilities**:
    *   `get_time_sec()`: Wraps `gettimeofday` to provide high-precision wall-clock time for performance profiling (e.g., measuring how long the BFS or the stopping check takes).

---

_**User (2025-11-28 09:13Z)**_

could the parameter alpha_sp_sampling be negective? Why?

---

_**Agent (model gemini-3-pro-preview, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Understanding the Alpha Parameter**

I'm currently focused on the `alpha_sp_sampling` parameter within the `silvan` project. I'm trying to determine whether it can take on negative values and understand the underlying rationale. Right now, I'm digging into `Sp_sampler.cpp` and `Probabilistic.cpp` to see how this parameter is actually employed.


**Examining Parameter Use**

I've been meticulously examining the `Sp_sampler.cpp` file and the `random_path` method. I've found a conditional statement where `alpha_sp_sampling` is compared to zero, indicating its potential for positive values. I've also just started a deeper dive into `Probabilistic.cpp`, especially the `Probabilistic::run` method to pinpoint initialization and any possible modifications to this critical parameter. My focus now is on understanding the cases where it is set to a negative value.


</details></think>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/src/Sp_sampler.cpp</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: silvan/src/Probabilistic.cpp</summary>

</details>
</tool-use>

---

<think><details><summary>Thought Process</summary>
**Considering Code Analysis**

I've been poring over the `Sp_sampler.cpp` and `Probabilistic.cpp` files within the `silvan/src` directory. I've noted a key conditional statement within `Sp_sampler.cpp` that seems to be a significant point of interest. I'm focusing on the interaction between `alpha_sp_sampling` and `tot_weight` as indicated on line 167. I plan to delve deeper into the dependencies of these variables.


**Exploring Heuristic Implications**

I'm now focusing on the implications of the heuristic. Setting `alpha_sp_sampling` to -1. based on the variance and centrality bounds appears to be a crucial control mechanism. This effectively disables the sampling strategy under certain conditions. I will now examine under what precise conditions this heuristic triggers, and what impact that has on the overall algorithm. I want to know why this heuristic exists.


**Unpacking Heuristic Purpose**

I've examined the direct impact of the heuristic. By setting `alpha_sp_sampling` to -1, we're effectively disabling the proportional sampling of shortest paths. This defaults `num_paths_to_sample` to 1, leading to a single shortest path sample per node pair. This is triggered when variance is high relative to centrality, suggesting a strategy to mitigate potential issues caused by high variance during sampling, or heavy concentration of paths. The overall effect seems to be to trade off variance for potential bias, particularly in regions where the graph structure is "wimpy".


**Pinpointing the Control Mechanism**

The dynamic setting of `alpha_sp_sampling` to -1. is a clear mechanism to switch between single-path and multi-path sampling. The crucial condition hinges on the ratio of `wimpy_var_upperbound` and `top1bc_upperbound`, but I must understand the meaning of `wimpy_var`. High relative variance compared to centrality signals the sampler to revert to default, simpler behavior.


**Interpreting the Heuristic**

I've confirmed my initial thoughts: when the heuristic in `Probabilistic.cpp` triggers, `alpha_sp_sampling` is indeed set to -1. This disables multi-path sampling, defaulting `num_paths_to_sample` to 1, effectively simplifying path selection. This occurs when variance is high relative to centrality, suggesting a deliberate trade-off. This reduces covariance in the sampled shortest paths. It prevents issues associated with high variance during sampling.


</details></think>

---

[I WILL OBEY THE USER RULES]

Yes, `alpha_sp_sampling` **can be negative**. It serves as a special flag to **disable multi-path sampling** and force the algorithm to sample exactly one shortest path per node pair.

### Technical Explanation

1.  **Behavior in `Sp_sampler.cpp`**:
    In the `random_path` function, the variable is checked as follows:
    ```cpp:166:silvan/src/Sp_sampler.cpp
    int num_paths_to_sample = 1;
    if (alpha_sp_sampling > 0. && tot_weight > 1){
       num_paths_to_sample = alpha_sp_sampling*tot_weight;
    }
    ```
    If `alpha_sp_sampling` is negative (e.g., `-1.0`), the condition `alpha_sp_sampling > 0.` fails. The code skips the calculation based on `tot_weight` (total number of shortest paths) and leaves `num_paths_to_sample` at its default value of **1**.

2.  **Why is it set to negative?**
    It is used as a heuristic in `Probabilistic.cpp` to dynamically turn off the multi-path sampling feature if the statistical variance is too high.

    In `Probabilistic::run`, the algorithm checks the "wimpy variance" (a measure of how much the estimator fluctuates):
    ```cpp:920:silvan/src/Probabilistic.cpp
      if(alpha_sp_given == false && wimpy_var_upperbound > 0.9 * top1bc_upperbound){
        alpha_sp_sampling = -1.;
      }
    ```
    *   **Condition**: If the user did not manually specify `alpha` (`alpha_sp_given == false`) AND the upper bound of the variance (`wimpy_var_upperbound`) is very close to the centrality estimate itself (`> 0.9 * top1bc_upperbound`).
    *   **Reasoning**: High variance indicates that the estimates are unstable. Sampling multiple paths between the same pair of nodes $(u, v)$ can introduce correlation (if the paths overlap significantly), which might not help reduce this specific type of variance efficiently. By setting it to `-1.`, the algorithm reverts to the safer, standard Monte Carlo approach of sampling strictly one path per pair to ensure independence and stabilize the bounds.

---

_**User (2025-12-03 06:29Z)**_



---

_**Agent (model gemini-3-pro-preview, mode Agent)**_

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "run_silvan.py argument parsing and execution" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `scripts/run_silvan.py` | L36 |
| `scripts/run_silvan.py` | L32-89 |
| `scripts/run_experiments.py` | L38 |
| `scripts/run_experiments_topk.py` | L44 |
| `scripts/run_experiments_ablation.py` | L40 |
| `scripts/run_bavarian.py` | L1-46 |
| `scripts/run_experiments_topk.py` | L40-73 |
| `scripts/run_kadabra.py` | L53 |
| `scripts/run_silvan.py` | L74-106 |
| `scripts/run_experiments_bavarian.py` | L21-80 |
| `scripts/run_experiments_bavarian.py` | L60 |
| `scripts/run_bavarian.py` | L44-68 |
| `scripts/preprocessing.py` | L53 |
| `scripts/run_kadabra.py` | L41-74 |
| `scripts/run_kadabra.py` | L38-56 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "Probabilistic::run output file format" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `silvan/src/Probabilistic.cpp` | L1085-1143 |
| `silvan/src/Probabilistic.cpp` | L38-79 |
| `silvan/src/Probabilistic.cpp` | L406-449 |
| `silvan/src/Probabilistic.cpp` | L770-826 |
| `silvan/src/Probabilistic.cpp` | L446-467 |
| `silvan/src/Probabilistic.cpp` | L660-688 |
| `silvan/src/Probabilistic.cpp` | L40 |
| `silvan/src/Probabilistic.cpp` | L1042-1090 |
| `silvan/src/Probabilistic.cpp` | L462-501 |
| `silvan/src/Probabilistic.cpp` | L361-415 |
| `silvan/src/Probabilistic.cpp` | L902-952 |
| `silvan/src/Probabilistic.cpp` | L247-277 |
| `silvan/src/Probabilistic.cpp` | L872-907 |
| `silvan/src/Probabilistic.cpp` | L553-586 |
| `silvan/src/Probabilistic.cpp` | L497-556 |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">
<details>
                <summary>Tool use: **codebase_search** • Searched codebase "write .mat file" • **15** results</summary>
            
| File | Lines |
|------|-------|
| `scripts/convert_to_mat.m` | L57 |
| `scripts/convert_to_mat.m` | L52-120 |
| `scripts/run_silvan.py` | L74-106 |
| `scripts/run_bavarian.py` | L44-68 |
| `scripts/run_silvan.py` | L32-89 |
| `scripts/run_kadabra.py` | L41-74 |
| `scripts/run_kadabra.py` | L53 |
| `scripts/run_bavarian.py` | L1-46 |
| `scripts/preprocessing.py` | L46-92 |
| `scripts/run_experiments.py` | L38 |
| `scripts/run_silvan.py` | L36 |
| `scripts/preprocessing.py` | L53 |
| `scripts/download_ds.py` | L37-90 |
| `scripts/run_experiments_topk.py` | L44 |
| `scripts/run_experiments_bavarian.py` | L60 |

</details>
</tool-use>

---

